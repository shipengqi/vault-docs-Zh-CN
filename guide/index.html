<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Getting Started | Vault 中文文档</title>
    <meta name="description" content="欢迎来到 HashiCorp Vault 介绍指南!本指南是开始使用 Vault 的最佳地点。本指南涵盖了Vault 是什么，它可以解决什么问题，它如何与现有软件进行比较，
并包含了使用 Vault 的快速入门。">
    <link rel="icon" href="/vault-docs-Zh-CN/logo.png">
    
    <link rel="preload" href="/vault-docs-Zh-CN/assets/css/styles.341f2fd2.css" as="style"><link rel="preload" href="/vault-docs-Zh-CN/assets/js/app.341f2fd2.js" as="script"><link rel="preload" href="/vault-docs-Zh-CN/assets/js/16.686d05ff.js" as="script"><link rel="prefetch" href="/vault-docs-Zh-CN/assets/css/1.styles.03294af5.css"><link rel="prefetch" href="/vault-docs-Zh-CN/assets/css/3.styles.c23ef979.css"><link rel="prefetch" href="/vault-docs-Zh-CN/assets/js/1.03294af5.js"><link rel="prefetch" href="/vault-docs-Zh-CN/assets/js/10.06280d87.js"><link rel="prefetch" href="/vault-docs-Zh-CN/assets/js/11.bcdf7111.js"><link rel="prefetch" href="/vault-docs-Zh-CN/assets/js/12.237d0fc4.js"><link rel="prefetch" href="/vault-docs-Zh-CN/assets/js/13.68dc0d8d.js"><link rel="prefetch" href="/vault-docs-Zh-CN/assets/js/14.92bdbbbe.js"><link rel="prefetch" href="/vault-docs-Zh-CN/assets/js/15.b2db5799.js"><link rel="prefetch" href="/vault-docs-Zh-CN/assets/js/2.1eb2df92.js"><link rel="prefetch" href="/vault-docs-Zh-CN/assets/js/3.c23ef979.js"><link rel="prefetch" href="/vault-docs-Zh-CN/assets/js/4.4470f8cc.js"><link rel="prefetch" href="/vault-docs-Zh-CN/assets/js/5.072add43.js"><link rel="prefetch" href="/vault-docs-Zh-CN/assets/js/6.4dd90ff1.js"><link rel="prefetch" href="/vault-docs-Zh-CN/assets/js/7.4656fea3.js"><link rel="prefetch" href="/vault-docs-Zh-CN/assets/js/8.a0b92025.js"><link rel="prefetch" href="/vault-docs-Zh-CN/assets/js/9.0280e8d3.js">
    <link rel="stylesheet" href="/vault-docs-Zh-CN/assets/css/1.styles.03294af5.css"><link rel="stylesheet" href="/vault-docs-Zh-CN/assets/css/3.styles.c23ef979.css"><link rel="stylesheet" href="/vault-docs-Zh-CN/assets/css/styles.341f2fd2.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/vault-docs-Zh-CN/" class="home-link router-link-active"><!----> <span class="site-name">Vault 中文文档</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/vault-docs-Zh-CN/guide/" class="nav-link router-link-exact-active router-link-active">入门指南</a></div><div class="nav-item"><a href="/vault-docs-Zh-CN/document/" class="nav-link">文档</a></div><div class="nav-item"><a href="/vault-docs-Zh-CN/api/" class="nav-link">API</a></div> <a href="https://github.com/shipengqi/vault-docs-Zh-CN" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/vault-docs-Zh-CN/guide/" class="nav-link router-link-exact-active router-link-active">入门指南</a></div><div class="nav-item"><a href="/vault-docs-Zh-CN/document/" class="nav-link">文档</a></div><div class="nav-item"><a href="/vault-docs-Zh-CN/api/" class="nav-link">API</a></div> <a href="https://github.com/shipengqi/vault-docs-Zh-CN" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first collapsable"><p class="sidebar-heading open"><span>入门指南</span> <span class="arrow down"></span></p> <ul class="sidebar-group-items"><li><a href="/vault-docs-Zh-CN/guide/" class="active sidebar-link">Getting Started</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vault-docs-Zh-CN/guide/#安装" class="sidebar-link">安装</a></li><li class="sidebar-sub-header"><a href="/vault-docs-Zh-CN/guide/#启动-server" class="sidebar-link">启动 server</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vault-docs-Zh-CN/guide/#启动-vault-server" class="sidebar-link">启动 Vault server</a></li><li class="sidebar-sub-header"><a href="/vault-docs-Zh-CN/guide/#校验-server-是否运行" class="sidebar-link">校验 server 是否运行</a></li></ul></li><li class="sidebar-sub-header"><a href="/vault-docs-Zh-CN/guide/#第一个-secret" class="sidebar-link">第一个 Secret</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vault-docs-Zh-CN/guide/#写一个-secret" class="sidebar-link">写一个 Secret</a></li><li class="sidebar-sub-header"><a href="/vault-docs-Zh-CN/guide/#读取一个-secret" class="sidebar-link">读取一个 Secret</a></li><li class="sidebar-sub-header"><a href="/vault-docs-Zh-CN/guide/#删除一个-secret" class="sidebar-link">删除一个 Secret</a></li></ul></li><li class="sidebar-sub-header"><a href="/vault-docs-Zh-CN/guide/#secrets-引擎" class="sidebar-link">Secrets 引擎</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vault-docs-Zh-CN/guide/#启用一个-secrets-引擎" class="sidebar-link">启用一个 secrets 引擎</a></li><li class="sidebar-sub-header"><a href="/vault-docs-Zh-CN/guide/#禁用一个-secrets-引擎" class="sidebar-link">禁用一个 secrets 引擎</a></li><li class="sidebar-sub-header"><a href="/vault-docs-Zh-CN/guide/#secrets-引擎是什么？" class="sidebar-link">secrets 引擎是什么？</a></li></ul></li><li class="sidebar-sub-header"><a href="/vault-docs-Zh-CN/guide/#dynamic-secrets" class="sidebar-link">Dynamic Secrets</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vault-docs-Zh-CN/guide/#启用-aws-secrets-引擎" class="sidebar-link">启用 AWS Secrets 引擎</a></li><li class="sidebar-sub-header"><a href="/vault-docs-Zh-CN/guide/#配置-aws-secrets-引擎" class="sidebar-link">配置 AWS Secrets 引擎</a></li><li class="sidebar-sub-header"><a href="/vault-docs-Zh-CN/guide/#创建-role" class="sidebar-link">创建 role</a></li><li class="sidebar-sub-header"><a href="/vault-docs-Zh-CN/guide/#生成-secret" class="sidebar-link">生成 Secret</a></li><li class="sidebar-sub-header"><a href="/vault-docs-Zh-CN/guide/#撤销-secret" class="sidebar-link">撤销 Secret</a></li></ul></li><li class="sidebar-sub-header"><a href="/vault-docs-Zh-CN/guide/#内置的帮助" class="sidebar-link">内置的帮助</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vault-docs-Zh-CN/guide/#路径帮助" class="sidebar-link">路径帮助</a></li></ul></li><li class="sidebar-sub-header"><a href="/vault-docs-Zh-CN/guide/#authentication" class="sidebar-link">Authentication</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vault-docs-Zh-CN/guide/#背景" class="sidebar-link">背景</a></li><li class="sidebar-sub-header"><a href="/vault-docs-Zh-CN/guide/#tokens" class="sidebar-link">Tokens</a></li><li class="sidebar-sub-header"><a href="/vault-docs-Zh-CN/guide/#auth-methods" class="sidebar-link">Auth Methods</a></li></ul></li><li class="sidebar-sub-header"><a href="/vault-docs-Zh-CN/guide/#policies" class="sidebar-link">Policies</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vault-docs-Zh-CN/guide/#策略格式" class="sidebar-link">策略格式</a></li><li class="sidebar-sub-header"><a href="/vault-docs-Zh-CN/guide/#编写策略" class="sidebar-link">编写策略</a></li><li class="sidebar-sub-header"><a href="/vault-docs-Zh-CN/guide/#测试策略" class="sidebar-link">测试策略</a></li><li class="sidebar-sub-header"><a href="/vault-docs-Zh-CN/guide/#映射策略到-auth-方法" class="sidebar-link">映射策略到 auth 方法</a></li></ul></li><li class="sidebar-sub-header"><a href="/vault-docs-Zh-CN/guide/#部署-vault" class="sidebar-link">部署 Vault</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vault-docs-Zh-CN/guide/#配置-vault" class="sidebar-link">配置 Vault</a></li><li class="sidebar-sub-header"><a href="/vault-docs-Zh-CN/guide/#启动-server-2" class="sidebar-link">启动 server</a></li><li class="sidebar-sub-header"><a href="/vault-docs-Zh-CN/guide/#初始化-vault" class="sidebar-link">初始化 Vault</a></li></ul></li><li class="sidebar-sub-header"><a href="/vault-docs-Zh-CN/guide/#seal-unseal" class="sidebar-link">Seal/Unseal</a></li><li class="sidebar-sub-header"><a href="/vault-docs-Zh-CN/guide/#使用带有身份验证的-http-apis" class="sidebar-link">使用带有身份验证的 HTTP APIs</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vault-docs-Zh-CN/guide/#通过-rest-apis-访问-secrets" class="sidebar-link">通过 REST APIs 访问 secrets</a></li></ul></li><li class="sidebar-sub-header"><a href="/vault-docs-Zh-CN/guide/#web-ui" class="sidebar-link">Web UI</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vault-docs-Zh-CN/guide/#dev-servers-2" class="sidebar-link">Dev servers</a></li><li class="sidebar-sub-header"><a href="/vault-docs-Zh-CN/guide/#non-dev-servers-2" class="sidebar-link">Non-Dev servers</a></li><li class="sidebar-sub-header"><a href="/vault-docs-Zh-CN/guide/#web-ui-wizard" class="sidebar-link">Web UI Wizard</a></li></ul></li></ul></li></ul></div></li></ul> </div> <div class="page"> <div class="content"><h1 id="getting-started"><a href="#getting-started" aria-hidden="true" class="header-anchor">#</a> Getting Started</h1> <h2 id="安装"><a href="#安装" aria-hidden="true" class="header-anchor">#</a> 安装</h2> <p><a href="https://www.vaultproject.io/downloads.html" target="_blank" rel="noopener noreferrer">下载地址<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">wget</span> <span class="token function">wget</span> https://releases.hashicorp.com/vault/0.11.4/vault_0.11.4_linux_amd64.zip
<span class="token function">mv</span> ./vault_0.11.4_linux_amd64.zip /usr/local/program/

<span class="token comment"># 解压 得到一个二进制文件 vault</span>
unzip vault_0.11.4_linux_amd64.zip

<span class="token comment"># 配置环境变量</span>
vim /etc/profile

<span class="token comment"># 添加下面的内容 /usr/local/program 改成你自己的安装目录</span>
VAULT_PATH<span class="token operator">=</span>/usr/local/program
<span class="token function">export</span> PATH<span class="token operator">=</span><span class="token variable">$VAULT_PATH</span><span class="token keyword">:</span><span class="token variable">$PATH</span>

<span class="token comment"># 使环境变量生效</span>
<span class="token function">source</span> /etc/profile

<span class="token comment"># 验证 vault</span>
vault

<span class="token comment"># 安装 子命令、标志和路径参数的命令行补全 自动安装 helper 到 ~/.bashrc</span>
vault -autocomplete-install
<span class="token function">exec</span> <span class="token variable">$SHELL</span>
</code></pre></div><h2 id="启动-server"><a href="#启动-server" aria-hidden="true" class="header-anchor">#</a> 启动 server</h2> <p>Vault 用作 client/server 应用程序。Vault server 是 Vault 架构中唯一与数据存储和后端交互的部分。通过 Vault CLI 完成的所有操作都通过 TLS 连接与服务器交互。</p> <h3 id="启动-vault-server"><a href="#启动-vault-server" aria-hidden="true" class="header-anchor">#</a> 启动 Vault server</h3> <p>首先我们开启 Vault 的 <code>dev server</code>，dev server 是一个内置的、预先配置好的服务器，它不是很安全，但对于本地使用 Vault 非常有用。只能用于开发环境。
运行：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>vault server -dev

<span class="token comment"># 输出</span>
<span class="token operator">==</span><span class="token operator">&gt;</span> Vault server configuration:

             Api Address: http://127.0.0.1:8200
                     Cgo: disabled
         Cluster Address: https://127.0.0.1:8201
              Listener 1: tcp <span class="token punctuation">(</span>addr: <span class="token string">&quot;127.0.0.1:8200&quot;</span>, cluster address: <span class="token string">&quot;127.0.0.1:8201&quot;</span>, max_request_duration: <span class="token string">&quot;1m30s&quot;</span>, max_request_size: <span class="token string">&quot;33554432&quot;</span>, tls: <span class="token string">&quot;disabled&quot;</span><span class="token punctuation">)</span>
               Log Level: <span class="token punctuation">(</span>not set<span class="token punctuation">)</span>
                   Mlock: supported: true, enabled: <span class="token boolean">false</span>
                 Storage: inmem
                 Version: Vault v0.11.4
             Version Sha: 612120e76de651ef669c9af5e77b27a749b0dba3

WARNING<span class="token operator">!</span> dev mode is enabled<span class="token operator">!</span> In this mode, Vault runs entirely in-memory
and starts unsealed with a single unseal key. The root token is already
authenticated to the CLI, so you can immediately begin using Vault.

You may need to <span class="token keyword">set</span> the following environment variable:

    $ <span class="token function">export</span> VAULT_ADDR<span class="token operator">=</span><span class="token string">'http://127.0.0.1:8200'</span>

The unseal key and root token are displayed below <span class="token keyword">in</span> <span class="token keyword">case</span> you want to
seal/unseal the Vault or re-authenticate.

Unseal Key: MG/XNYH+rCMgPE8QMIisDSRBmiNpzAmUI/Rj75RZ/XY<span class="token operator">=</span>
Root Token: 2oYMZEsFTi9bfeqKIcwwKMxP

Development mode should NOT be used <span class="token keyword">in</span> production installations<span class="token operator">!</span>

<span class="token operator">==</span><span class="token operator">&gt;</span> Vault server started<span class="token operator">!</span> Log data will stream <span class="token keyword">in</span> below:

<span class="token comment"># ...</span>
</code></pre></div><p>这是 Vault 开发服务器已经启动，不要关闭终端选项卡，打开一个新的选项卡，运行其他命令。</p> <p>dev server 所有的数据都存储在内存（加密的），在没有 TLS 的 <code>localhost</code> 上侦听，并自动解封并显示 <code>unseal key</code> 和 <code>root access key</code>。</p> <p>dev server 运行后，先做下面三件事：</p> <ol><li>打开一个新的终端会话。</li> <li>复制并运行上面终端输出的命令 <code>export VAULT_ADDR='http://127.0.0.1:8200'</code>，这会配置 Vault 客户端与我们的 dev server 通信。</li> <li>复制终端输出的 <code>Unseal Key</code>，保存到任意的地方。</li> <li>复制终端输出的 <code>Root Token</code>，并设置到环境变量 <code>export VAULT_DEV_ROOT_TOKEN_ID=&quot;s.XmpNPoi9sRhYtdKHaQhkHP6x&quot;</code></li></ol> <h3 id="校验-server-是否运行"><a href="#校验-server-是否运行" aria-hidden="true" class="header-anchor">#</a> 校验 server 是否运行</h3> <p>打开新的终端，运行 <code>export VAULT_ADDR='http://127.0.0.1:8200'</code>：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token comment"># 校验</span>
vault status

<span class="token comment"># 输出</span>
Key             Value
---             -----
Seal Type       shamir
Initialized     <span class="token boolean">true</span>
Sealed          <span class="token boolean">false</span>
Total Shares    1
Threshold       1
Version         0.11.4
Cluster Name    vault-cluster-8ffc02c5
Cluster ID      6a450d7d-e4aa-b636-e338-619aff7c3626
HA Enabled      <span class="token boolean">false</span>
</code></pre></div><p>如果输出看起来不一样，特别是如果数字不同或 Vault 是 <code>sealed</code>，那么重新启动 dev server 并再次尝试。</p> <h2 id="第一个-secret"><a href="#第一个-secret" aria-hidden="true" class="header-anchor">#</a> 第一个 Secret</h2> <p>现在 dev server 已经运行，开始读写我们第一个 Secret。</p> <p>Vault 的核心特性之一就是安全读写任意的 secrets 。可以通过 CLI，但是也有一个完整的<a href="https://www.vaultproject.io/api/index.html" target="_blank" rel="noopener noreferrer">HTTP API<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，可以通过编程的方式
使用 Vault 做任何事情。</p> <p>写入 Vault 的信息会被加密，然后再写入后端存储。对于 dev server，后端存储是在内存中，但是在生产环境下，应该是磁盘或者<a href="https://www.consul.io/" target="_blank" rel="noopener noreferrer">Consul<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。
Vault 在将值传递给存储驱动程序之前对其进行加密。后端存储机制永远不会看到未加密的值，在没有 Vault 的情况下，也没有方法解密它。</p> <h3 id="写一个-secret"><a href="#写一个-secret" aria-hidden="true" class="header-anchor">#</a> 写一个 Secret</h3> <p>使用<code>vault kv</code>命令写入：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>vault kv put secret/hello foo<span class="token operator">=</span>world

<span class="token comment"># 输出</span>
Key              Value
---              -----
created_time     2019-02-04T19:53:22.730733Z
deletion_time    n/a
destroyed        <span class="token boolean">false</span>
version          1

<span class="token comment"># 写入多对</span>
vault kv put secret/hello foo<span class="token operator">=</span>world excited<span class="token operator">=</span>yes
</code></pre></div><p>将一对值 <code>foo=world</code> 写入路径 <code>secret/hello</code>。这个<strong>路径的前缀 <code>secret/</code> 很重要</strong>，否则这个示例将无法工作。<code>secret/</code> 前缀是任意 secrets 可以读写的地方。</p> <p><code>vault kv put</code>是一个非常强大的命令。除了直接从命令行写入数据外，它还可以从 <code>STDIN</code> 以及文件中读取值和密钥对。
更多信息，参阅<a href="https://www.vaultproject.io/docs/commands/index.html" target="_blank" rel="noopener noreferrer">命令文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <blockquote><p><strong>但如果可能的话，使用文件更安全。通过 CLI 发送数据通常记录在 <code>shell</code> 历史记录中。对于重要 secrets ，请使用文件。</strong></p></blockquote> <h3 id="读取一个-secret"><a href="#读取一个-secret" aria-hidden="true" class="header-anchor">#</a> 读取一个 Secret</h3> <p>使用 <code>vault get</code> 读取：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>vault kv get secret/hello

<span class="token comment"># 输出</span>
<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span> Metadata <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>
Key              Value
---              -----
created_time     2018-10-31T06:05:53.226450737Z
deletion_time    n/a
destroyed        <span class="token boolean">false</span>
version          2

<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span> Data <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span>
Key        Value
---        -----
excited    <span class="token function">yes</span>
foo        world
</code></pre></div><p>Vault 从存储中获取数据并解密。</p> <p>添加参数 <code>-format=json</code>，可以输出<code>json</code>格式：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>vault kv get -format<span class="token operator">=</span>json secret/hello

<span class="token comment"># 输出</span>
<span class="token punctuation">{</span>
  <span class="token string">&quot;request_id&quot;</span><span class="token keyword">:</span> <span class="token string">&quot;3496c75c-9247-4d49-7ac4-8d821aa0bf43&quot;</span>,
  <span class="token string">&quot;lease_id&quot;</span><span class="token keyword">:</span> <span class="token string">&quot;&quot;</span>,
  <span class="token string">&quot;lease_duration&quot;</span><span class="token keyword">:</span> 0,
  <span class="token string">&quot;renewable&quot;</span><span class="token keyword">:</span> false,
  <span class="token string">&quot;data&quot;</span><span class="token keyword">:</span> <span class="token punctuation">{</span>
    <span class="token string">&quot;data&quot;</span><span class="token keyword">:</span> <span class="token punctuation">{</span>
      <span class="token string">&quot;excited&quot;</span><span class="token keyword">:</span> <span class="token string">&quot;yes&quot;</span>,
      <span class="token string">&quot;foo&quot;</span><span class="token keyword">:</span> <span class="token string">&quot;world&quot;</span>
    <span class="token punctuation">}</span>,
    <span class="token string">&quot;metadata&quot;</span><span class="token keyword">:</span> <span class="token punctuation">{</span>
      <span class="token string">&quot;created_time&quot;</span><span class="token keyword">:</span> <span class="token string">&quot;2018-10-31T06:05:53.226450737Z&quot;</span>,
      <span class="token string">&quot;deletion_time&quot;</span><span class="token keyword">:</span> <span class="token string">&quot;&quot;</span>,
      <span class="token string">&quot;destroyed&quot;</span><span class="token keyword">:</span> false,
      <span class="token string">&quot;version&quot;</span><span class="token keyword">:</span> 2
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>,
  <span class="token string">&quot;warnings&quot;</span><span class="token keyword">:</span> null
<span class="token punctuation">}</span>

<span class="token comment"># 可以结合 jq 使用</span>
vault kv get -format<span class="token operator">=</span>json secret/hello <span class="token operator">|</span> jq -r .data.data.excited

<span class="token comment"># 输出</span>
<span class="token function">yes</span>
</code></pre></div><p>也可以直接获取指定的字段：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>vault kv get -field<span class="token operator">=</span>excited secret/hello

<span class="token comment"># 输出</span>
<span class="token function">yes</span>
</code></pre></div><h3 id="删除一个-secret"><a href="#删除一个-secret" aria-hidden="true" class="header-anchor">#</a> 删除一个 Secret</h3> <p><code>vault delete</code>命令删除：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>vault kv delete secret/hello

<span class="token comment"># 输出</span>
Success<span class="token operator">!</span> Data deleted <span class="token punctuation">(</span>if it existed<span class="token punctuation">)</span> at: secret/hello
</code></pre></div><h2 id="secrets-引擎"><a href="#secrets-引擎" aria-hidden="true" class="header-anchor">#</a> Secrets 引擎</h2> <p>我们前面的读写操作。你应该注意到所有的请求都以 <code>secret/</code> 开头。如果尝试使用不同的前缀，Vault 会返回一个错误:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>vault <span class="token function">write</span> foo/bar a<span class="token operator">=</span>b

<span class="token comment"># 输出</span>
Error writing data to foo/bar: Error making API request.

URL: PUT http://127.0.0.1:8200/v1/foo/bar
Code: 404. Errors:

* no handler <span class="token keyword">for</span> route <span class="token string">'foo/bar'</span>
</code></pre></div><p>同样的，<code>vault kv put foo/bar a=b</code> 也会返回一个错误。</p> <p><strong>路径前缀告诉 Vault 应该路由到哪个 secrets 引擎</strong>。当请求到达 Vault 时，它使用最长的前缀匹配，匹配初始路径部分，然后将请求传递给相应的 secrets 引擎。</p> <p>默认情况下，Vault 在路径 <code>secret/</code> 上启用了一个名为 <code>kv</code> 的 secrets 引擎。<code>kv</code> secrets 引擎将原始数据读写到后端存储。</p> <p>Vault 除了 <code>kv</code> 还支持多种 secrets 引擎，这个特性使 Vault 变得灵活。例如，<code>aws</code> secrets 引擎需要生成 <code>aws IAM access keys</code> 。
<code>database</code> secrets 引擎生成按需的、有时间限制的数据库凭证。这只是一些可用的 secrets 引擎的例子。</p> <p>为了简单，Vault 提供的这些 secrets 引擎了类似于文件系统。一个 secrets 引擎启用在一个路径上。Vault 本身在传入请求上执行前缀路由，
并根据启用的路径将请求路由到正确的 secrets 引擎。</p> <h3 id="启用一个-secrets-引擎"><a href="#启用一个-secrets-引擎" aria-hidden="true" class="header-anchor">#</a> 启用一个 secrets 引擎</h3> <p>我们启用一个 <code>kv</code>  secrets 引擎在一个不同的路径上，像文件系统一样，我们可以在多个不同的路径上启用一个 secrets 引擎。
每个路径都是完全隔离的，不能与其他路径通信。例如，在 <code>foo</code> 路径上的<code>kv</code> secrets 引擎,不能和在 <code>bar</code> 路径上的<code>kv</code> secrets 引擎通信。
启用：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>vault secrets <span class="token function">enable</span> -path<span class="token operator">=</span>kv kv

<span class="token comment"># 输出</span>
Success<span class="token operator">!</span> Enabled the kv secrets engine at: kv/
</code></pre></div><p>在 <code>kv/</code> 路径上启用了<code>kv</code> secrets 引擎。<strong>启用 secrets 引擎的路径默认是 secrets 引擎的名称</strong>。也就是说 <code>vault secrets enable kv</code> 和上面的命令
是一样的效果。</p> <p>查看是否操作成功，获取 secrets 引擎更多信息，使用 <code>vault secrets list</code> 命令：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>vault secrets list

<span class="token comment"># 输出 n/a 表示没有描述</span>
Path          Type         Accessor              Description
----          ----         --------              -----------
cubbyhole/    cubbyhole    cubbyhole_acf26a2e    per-token private secret storage
identity/     identity     identity_3cdd7b91     identity store
kv/           kv           kv_457c99be           n/a
secret/       kv           kv_548de4c3           key/value secret storage
sys/          system       system_6ab143cf       system endpoints used <span class="token keyword">for</span> control, policy and debugging
</code></pre></div><h3 id="禁用一个-secrets-引擎"><a href="#禁用一个-secrets-引擎" aria-hidden="true" class="header-anchor">#</a> 禁用一个 secrets 引擎</h3> <p>如果 secrets 引擎被禁用了，那么所有的 secrets 会被撤销，相应的 Vault 数据和配置会被删除。任何将数据路由到该路径的请求都会导致错误，
但是现在该路径可以启用另一个 secrets 引擎了。</p> <p>如果由于某种原因，Vault 无法删除数据或撤销租约，禁用操作将失败。如果发生这种情况，secrets 引擎将保持启用和可用，但是请求将返回一个错误。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>vault secrets disable kv/
</code></pre></div><p>注意<strong>这个命令的参数不是 secrets 引擎的类型，而是 secrets 引擎对应的路径</strong>。</p> <p>还可以将 secrets 引擎移动到新的路径。这仍然是一个破坏性的命令。所有配置数据都被保留，但是任何 secrets 都被撤销，因为 secrets 与引擎的路径紧密相连。</p> <h3 id="secrets-引擎是什么？"><a href="#secrets-引擎是什么？" aria-hidden="true" class="header-anchor">#</a> secrets 引擎是什么？</h3> <p>上面提到，Vault 的行为类似于虚拟文件系统。<code>get/write/delete/list</code> 操作被转发到相应的 secrets 引擎，secrets 引擎决定如何对这些操作作出反应。</p> <p>这种抽象非常强大。它使 Vault 可以直接与物理系统、数据库、HSMs等进行交互。但是除了这些物理系统之外，Vault 还可以与更独特的环境进行交互，比如 AWS IAM，动态 SQL 用户创建，
并且同时使用相同的读写接口。</p> <h2 id="dynamic-secrets"><a href="#dynamic-secrets" aria-hidden="true" class="header-anchor">#</a> Dynamic Secrets</h2> <p>和 <code>kv</code> secrets 不同的是，你不需要自己将数据放入存储中，<strong>Dynamic secrets 是在访问它们时生成的。Dynamic secrets 在被读取之前是不存在的，
因此不存在有人窃取它们或其他客户使用相同 secrets 的风险</strong>。由于 Vault 具有内置的撤销机制，Dynamic secrets 可以在使用后立即撤销，从而最小化了 secrets 存在的时间。</p> <h3 id="启用-aws-secrets-引擎"><a href="#启用-aws-secrets-引擎" aria-hidden="true" class="header-anchor">#</a> 启用 AWS Secrets 引擎</h3> <p>AWS secrets 引擎不像 <code>kv</code> secrets 引擎一样被默认启用，需要自己在使用前启用。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>vault secrets <span class="token function">enable</span> -path<span class="token operator">=</span>aws aws
</code></pre></div><p>正如我们在前几节中所讨论的，不同的 secrets 引擎允许不同的行为。这个例子中，AWS secrets 引擎生成动态的、按需的 AWS 访问凭证。</p> <h3 id="配置-aws-secrets-引擎"><a href="#配置-aws-secrets-引擎" aria-hidden="true" class="header-anchor">#</a> 配置 AWS Secrets 引擎</h3> <p>在启用 AWS secrets 引擎之后，必须将其配置为进行身份验证并与 AWS 进行通信。这需要特权帐户凭证。如果你不熟悉 AWS，请使用根帐户密钥（<strong>不要在生产环境下使用根帐户密钥</strong>）。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>vault <span class="token function">write</span> aws/config/root \
   access_key<span class="token operator">=</span>AKIAI4SGLQPBX6CSENIQ \
   secret_key<span class="token operator">=</span>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

<span class="token comment"># 输出</span>
Success<span class="token operator">!</span> Data written to: aws/config/root
</code></pre></div><p>这些凭证现在存储在这个 AWS secrets 引擎中。在将来的请求中，引擎将在与 AWS 通信时使用这些凭证。</p> <h3 id="创建-role"><a href="#创建-role" aria-hidden="true" class="header-anchor">#</a> 创建 <code>role</code></h3> <p>配置一个 <code>role</code>，Vault 中 <code>role</code> 是对操作友好的标识符。把它看作一个符号链接。</p> <p>Vault 知道如何通过 AWS API 创建 IAM 用户，但是它不知道想要附加到该用户的权限、组和策略。这就是 <code>role</code> 的作用—— <code>role</code> 将你的配置选项映射到那些 API 调用。</p> <p>例如，这里有一个支持 EC2 上所有操作的 IAM 策略。当 Vault 生成访问密钥时，它将自动附加此策略。生成的访问密钥访问 EC2 (由此策略决定)的所有权限，但不能访问 IAM 或其他 AWS 服务。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token punctuation">{</span>
  <span class="token string">&quot;Version&quot;</span><span class="token keyword">:</span> <span class="token string">&quot;2012-10-17&quot;</span>,
  <span class="token string">&quot;Statement&quot;</span><span class="token keyword">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span>
      <span class="token string">&quot;Sid&quot;</span><span class="token keyword">:</span> <span class="token string">&quot;Stmt1426528957000&quot;</span>,
      <span class="token string">&quot;Effect&quot;</span><span class="token keyword">:</span> <span class="token string">&quot;Allow&quot;</span>,
      <span class="token string">&quot;Action&quot;</span><span class="token keyword">:</span> <span class="token punctuation">[</span><span class="token string">&quot;ec2:*&quot;</span><span class="token punctuation">]</span>,
      <span class="token string">&quot;Resource&quot;</span><span class="token keyword">:</span> <span class="token punctuation">[</span><span class="token string">&quot;*&quot;</span><span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如上所述，我们需要将这个策略文档映射到一个指定的 <code>role</code>。为此，向 <code>aws/roles/:name</code> 这里 <code>:name</code> 是描述角色的唯一名称(比如 <code>aws/roles/my-role</code>):</p> <div class="language-bash extra-class"><pre class="language-bash"><code>vault <span class="token function">write</span> aws/roles/my-role policy<span class="token operator">=</span>-<span class="token operator">&lt;&lt;</span><span class="token string">EOF
{
  &quot;Version&quot;: &quot;2012-10-17&quot;,
  &quot;Statement&quot;: [
    {
      &quot;Sid&quot;: &quot;Stmt1426528957000&quot;,
      &quot;Effect&quot;: &quot;Allow&quot;,
      &quot;Action&quot;: [
        &quot;ec2:*&quot;
      ],
      &quot;Resource&quot;: [
        &quot;*&quot;
      ]
    }
  ]
}
EOF</span>

<span class="token comment"># 输出</span>
Success<span class="token operator">!</span> Data written to: aws/roles/my-role
</code></pre></div><h3 id="生成-secret"><a href="#生成-secret" aria-hidden="true" class="header-anchor">#</a> 生成 Secret</h3> <p>现在，AWS secrets 引擎已经启用并配置了一个 <code>role</code>，我们可以通过从 AWS <code>/creds/:name</code>（<code>:name</code> 对应一个已经存在的 <code>role</code> name）中读取来请求 Vault 为该 <code>role</code> 生成一
个访问密钥对:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>vault <span class="token function">read</span> aws/creds/my-role

<span class="token comment"># 输出</span>
Key                Value
---                -----
lease_id           aws/creds/my-role/0bce0782-32aa-25ec-f61d-c026ff22106e
lease_duration     768h
lease_renewable    <span class="token boolean">true</span>
access_key         AKIAJELUDIANQGRXCTZQ
secret_key         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
security_token     <span class="token operator">&lt;</span>nil<span class="token operator">&gt;</span>
</code></pre></div><p><code>access key</code> 和 <code>secret key</code> 现在可以用于在 AWS 中执行任何 EC2 操作。注意，这些 <code>key</code> 是新的，它们不是你先前输入的 <code>key</code>.
如果你要再次运行该命令，你会得到一个新的访问密钥对。每次从 <code>aws/creds/:name</code> 中读取数据时，Vault 就会连接到 aws 并生成一个新的 IAM 用户和密钥对。</p> <p>注意输出中的 <code>lease_id</code> 字段。此值用于更新、撤销和检查。将此 <code>lease_id</code> 复制到剪贴板。注意，<code>lease_id</code> 是完整的路径，而不仅仅是末尾的 UUID。</p> <h3 id="撤销-secret"><a href="#撤销-secret" aria-hidden="true" class="header-anchor">#</a> 撤销 Secret</h3> <p>Vault 将在 768 小时后自动撤销此凭据(查看上面输出中的 <code>lease_duration</code> 字段)，但我们可能希望尽早撤销它。一旦密钥被撤销，访问密钥就不再有效。</p> <p>若要撤消 Secret ，使用 <code>vault revoke</code> 加上之前保存的 <code>lease_id</code>:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ vault lease revoke aws/creds/my-role/0bce0782-32aa-25ec-f61d-c026ff22106

Success<span class="token operator">!</span> Revoked lease: aws/creds/my-role/0bce0782-32aa-25ec-f61d-c026ff22106e
</code></pre></div><p>完成了!如果要登录到 AWS 帐户，会看到不存在 IAM 用户。如果尝试使用生成的访问键，会发现它们不再工作。</p> <p>有了这样简单的动态创建和撤销，就可以开始看到使用 Dynamic Secrets 是多么容易，并确保它们只在需要的时间内存在。</p> <h2 id="内置的帮助"><a href="#内置的帮助" aria-hidden="true" class="header-anchor">#</a> 内置的帮助</h2> <p>你现在已经使用了 <code>vault write</code> 和 <code>vault read</code> 来处理多个路径:<code>kv</code> secrets 引擎(带有 <code>kv/</code>)和 AWS secrets 引擎提供商(位于 <code>aws/</code>)的动态 AWS 证书。</p> <p>在这两种情况下，每个 secrets 引擎的结构和用法都不同，例如 AWS 后端有一些特殊的路径，比如 <code>aws/config</code>。</p> <p>Vault 有一个内置的帮助系统，而不是必须不断地记住或参考文档以确定使用什么路径。这个帮助系统可以通过 API 或命令行访问，并为任何路径生成可读的帮助。
本小节假设你已经启用了 AWS secerts 引擎在 <code>aws/</code> 路径上。使用 <code>vault path-help</code> 命令：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ vault path-help aws

<span class="token comment">### DESCRIPTION</span>

The AWS backend dynamically generates AWS access keys <span class="token keyword">for</span> a <span class="token keyword">set</span> of
IAM policies. The AWS access keys have a configurable lease <span class="token keyword">set</span> and
are automatically revoked at the end of the lease.

After mounting this backend, credentials to generate IAM keys must
be configured with the <span class="token string">&quot;root&quot;</span> path and policies must be written using
the <span class="token string">&quot;roles/&quot;</span> endpoints before any access keys can be generated.

<span class="token comment">### PATHS</span>

The following paths are supported by this backend. To view <span class="token function">help</span> <span class="token keyword">for</span>
any of the paths below, use the <span class="token function">help</span> <span class="token function">command</span> with any route matching
the path pattern. Note that depending on the policy of your auth token,
you may or may not be able to access certain paths.

    ^config/lease$
        Configure the default lease information <span class="token keyword">for</span> generated credentials.

    ^config/root$
        Configure the root credentials that are used to manage IAM.

    ^creds/<span class="token punctuation">(</span>?P<span class="token operator">&lt;</span>name<span class="token operator">&gt;</span>\w+<span class="token punctuation">)</span>$
        Generate an access key pair <span class="token keyword">for</span> a specific role.

    ^roles/<span class="token punctuation">(</span>?P<span class="token operator">&lt;</span>name<span class="token operator">&gt;</span>\w+<span class="token punctuation">)</span>$
        Read and <span class="token function">write</span> IAM policies that access keys can be made for.
</code></pre></div><p><code>vault path-help</code> 命令带上一个路径。指定 <code>root</code> 路径，会获得 secrets 引擎的概述。
注意，帮助不仅包含描述，还包含用于匹配该后端路由的精确正则表达式，以及关于路由的简要描述。</p> <h3 id="路径帮助"><a href="#路径帮助" aria-hidden="true" class="header-anchor">#</a> 路径帮助</h3> <p>我们可以通过为单个路径寻求帮助来继续深入研究。为此，只需使用 <code>vault path-help</code> 提供与该路径的正则表达式匹配的路径。
注意，这个路径实际上不需要是正确的。例如，我们将获得以下帮助来访问 <code>aws/creds/my-non-existent-role</code>，尽管我们从未创建过这个角色:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ vault path-help aws/creds/my-non-existent-role

Request:        creds/my-non-existent-role
Matching Route: ^creds/<span class="token punctuation">(</span>?P<span class="token operator">&lt;</span>name<span class="token operator">&gt;</span>\w<span class="token punctuation">((</span><span class="token punctuation">[</span>\w-.<span class="token punctuation">]</span>+<span class="token punctuation">)</span>?\w<span class="token punctuation">)</span>?<span class="token punctuation">)</span>$

Generate an access key pair <span class="token keyword">for</span> a specific role.

<span class="token comment">### PARAMETERS</span>

    name <span class="token punctuation">(</span>string<span class="token punctuation">)</span>
        Name of the role

<span class="token comment">### DESCRIPTION</span>

This path will generate a new, never before used key pair <span class="token keyword">for</span>
accessing AWS. The IAM policy used to back this key pair will be
the <span class="token string">&quot;name&quot;</span> parameter. For example, <span class="token keyword">if</span> this backend is mounted at <span class="token string">&quot;aws&quot;</span>,
<span class="token keyword">then</span> <span class="token string">&quot;aws/creds/deploy&quot;</span> would generate access keys <span class="token keyword">for</span> the <span class="token string">&quot;deploy&quot;</span> role.

The access keys will have a lease associated with them. The access keys
can be revoked by using the lease ID.
</code></pre></div><h2 id="authentication"><a href="#authentication" aria-hidden="true" class="header-anchor">#</a> Authentication</h2> <p>到目前为止，我们还没有登录到 Vault。<strong>在 dev 模式下启动 Vault 服务器时，它会自动将你作为具有管理权限的根用户登录。
在非 dev 设置中，必须首先进行身份验证</strong>。</p> <p>身份验证是向 Vault 用户分配身份的机制。</p> <p>Vault 具有可插入的 <code>auth</code> 方法，使用最适合你组织的任何形式的 Vault 很容易进行身份验证。</p> <h3 id="背景"><a href="#背景" aria-hidden="true" class="header-anchor">#</a> 背景</h3> <p>身份验证是验证用户或机器提供的信息并将其转换为匹配策略的 Vault token 的过程。理解 Vault 认证最简单的方法是将其与网站进行比较。</p> <p>当用户对网站进行身份验证时，他们会输入用户名、密码，可能还有 2FA 码。这些信息是通过外部来源(很可能是数据库)进行验证的，网站会以成功或失败作为回应。
成功后，网站还返回一个签名 <code>cookie</code>，其中包含唯一标识该会话用户的 <code>session id</code>。浏览器会自动将 <code>cookie</code> 和 <code>session id</code> 携带到将来的请求中，以便对用户进行身份验证。</p> <p>Vault 的行为非常相似，但它比标准网站更加灵活和可插入。Vault 支持许多不同的身份验证机制，但它们都汇入一个 <code>session token</code>，我们称之为 <code>Vault token</code>。
身份验证就是用户或机器获取 Vault 令牌的过程。</p> <h3 id="tokens"><a href="#tokens" aria-hidden="true" class="header-anchor">#</a> Tokens</h3> <p><code>Token</code> 身份验证在 Vault 中默认启用，不能禁用。当使用 <code>vault server -dev</code>启动开发服务器时，它会打印出你的 <code>root token</code>。<code>root token</code> 是配置 Vault 的初始访问令牌。
它具有 root 权限，因此可以在 Vault 中执行任何操作。</p> <p>可以创建更多 tokens：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ vault token create

Key                  Value
---                  -----
token                8BveWcnoQUz8fLUzTyuu0YHv
token_accessor       288UkgZjXvKPJHxR3QqzZOa4
token_duration       âˆž
token_renewable      <span class="token boolean">false</span>
token_policies       <span class="token punctuation">[</span><span class="token string">&quot;root&quot;</span><span class="token punctuation">]</span>
identity_policies    <span class="token punctuation">[</span><span class="token punctuation">]</span>
policies             <span class="token punctuation">[</span><span class="token string">&quot;root&quot;</span><span class="token punctuation">]</span>
</code></pre></div><p>默认情况下，这将创建当前令牌的子令牌，并且继承所有相同策略。这里** <code>child</code> 概念非常重要: 令牌总是有一个父令牌，当父令牌被撤销时，子令牌也可以在同一个操作中全部被撤销。
这使得在删除用户访问权限时很容易，也可以删除用户创建的所有子令牌的访问权限**。</p> <p>使用 <code>token</code> 验证：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ vault login rXURJUktdBdlgeOG5xkh8jAW

Success<span class="token operator">!</span> You are now authenticated. The token information displayed below
is already stored <span class="token keyword">in</span> the token helper. You <span class="token keyword">do</span> NOT need to run <span class="token string">&quot;vault login&quot;</span>
again. Future Vault requests will automatically use this token.

Key                  Value
---                  -----
token                rXURJUktdBdlgeOG5xkh8jAW
token_accessor       4QCLf891dUg26EzTgbrHQIWS
token_duration       âˆž
token_renewable      <span class="token boolean">false</span>
token_policies       <span class="token punctuation">[</span><span class="token string">&quot;root&quot;</span><span class="token punctuation">]</span>
identity_policies    <span class="token punctuation">[</span><span class="token punctuation">]</span>
policies             <span class="token punctuation">[</span><span class="token string">&quot;root&quot;</span><span class="token punctuation">]</span>
</code></pre></div><p>使用 <code>token</code> 验证，它会验证令牌，并让你知道该令牌与什么访问策略相关联。</p> <p>撤销创建好的 tokens：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ vault token revoke 8BveWcnoQUz8fLUzTyuu0YHv

Success<span class="token operator">!</span> Revoked token <span class="token punctuation">(</span>if it existed<span class="token punctuation">)</span>
</code></pre></div><p><code>vault lease revoke</code> 只能用于撤销 <code>lease</code>。</p> <p>使用 root token 重新登录：</p> <div class="language-sh extra-class"><pre class="language-text"><code>$ vault login $VAULT_DEV_ROOT_TOKEN_ID
</code></pre></div><h4 id="推荐模式"><a href="#推荐模式" aria-hidden="true" class="header-anchor">#</a> 推荐模式</h4> <p>实际上，操作人员不应该使用 <code>token create</code> 命令为用户或机器生成 Vault token。用户或机器应该使用 Vault 配置的 <code>auth</code> 方法(如 GitHub、LDAP、AppRole 等)
进行 Vault 身份验证。对于不能生成自己的令牌的遗留应用程序，操作人员可能需要提前创建令牌。</p> <h3 id="auth-methods"><a href="#auth-methods" aria-hidden="true" class="header-anchor">#</a> Auth Methods</h3> <p>Vault 支持许多 <code>auth</code> 方法，但是在使用之前必须启用它们。<code>auth</code> 方法提供了灵活性。启用和配置 <code>auth</code> 方法通常由 Vault 操作人员或安全团队执行。
作为一个以人为中心的 <code>auth</code> 方法的示例，让我们通过 GitHub 进行身份验证。</p> <p>首先，启用 GitHub <code>auth</code>方法：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ vault auth <span class="token function">enable</span> -path<span class="token operator">=</span>github github

Success<span class="token operator">!</span> Enabled github auth method at: github/
</code></pre></div><p>和 secrets 引擎一样，<code>auth</code> 方法默认以其 TYPE 作为 PATH，因此 <code>vault auth enable github</code> 与上面的命令是等价的。</p> <p>与在根路由器上启用的 secrets 引擎不同，<code>auth</code> 方法总是以 <code>auth/</code> 作为前缀。因此，我们刚刚启用的 GitHub <code>auth</code> 方法可以在 <code>auth/github</code> 上访问。
另一个例子：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ vault auth <span class="token function">enable</span> -path<span class="token operator">=</span>my-github github

Success<span class="token operator">!</span> Enabled github auth method at: my-github/
</code></pre></div><p>这样就可以在 <code>auth/my-github</code> 上访问 GitHub 的 <code>auth</code> 方法。使用 <code>ault path-help</code> 了解更多关于路径的信息。</p> <p>接下来，配置 GitHub <code>auth</code> 方法。每个 <code>auth</code> 方法都有不同的配置选项，所以详细信息请参阅文档。在这种情况下，最小的配置集是将团队映射到策略。
对于 GitHub，我们告诉它哪些组织用户必须是它的一部分，并将团队映射到策略</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ vault <span class="token function">write</span> auth/github/config organization<span class="token operator">=</span>hashicorp

Success<span class="token operator">!</span> Data written to: auth/github/config

$ vault <span class="token function">write</span> auth/github/map/teams/my-team value<span class="token operator">=</span>default,my-policy

Success<span class="token operator">!</span> Data written to: auth/github/map/teams/my-team
</code></pre></div><p>第一个命令配置 Vault 从 GitHub 上的 <code>hashicorp</code> 组织中拉去身份验证数据。下一个命令告诉 Vault 映射 <code>my-team</code>团队中(在 <code>hashicorp</code> 组织中)的任何用户，
以映射到策略 <code>default</code> 和 <code>my-policy</code>。这些策略还不需要存在于系统中—— Vault 在登录时只会发出警告。</p> <p>作为用户，可能希望找到启用和可用的 <code>auth</code> 方法：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ vault auth list

Path          Type      Accessor                Description
----          ----      --------                -----------
github/       github    auth_github_4e694978    n/a
my-github/    github    auth_github_2a45ccd0    n/a
token/        token     auth_token_5edaec25     token based credentials
</code></pre></div><p>要了解更多关于如何通过 CLI 对特定 <code>auth</code> 方法进行身份验证的信息，使用 <code>vault auth help</code> 命令和 <code>auth</code> 方法的 <code>PATH</code> 或 <code>TYPE</code> 一起使用：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ vault auth <span class="token function">help</span> github

Usage: vault login -method<span class="token operator">=</span>github <span class="token punctuation">[</span>CONFIG K<span class="token operator">=</span>V<span class="token punctuation">..</span>.<span class="token punctuation">]</span>

  The GitHub auth method allows <span class="token function">users</span> to authenticate using a GitHub
  personal access token. Users can generate a personal access token from the
  settings page on their GitHub account.

  Authenticate using a GitHub token:

      $ vault login -method<span class="token operator">=</span>github token<span class="token operator">=</span>abcd1234

Configuration:

  mount<span class="token operator">=</span><span class="token operator">&lt;</span>string<span class="token operator">&gt;</span>
      Path where the GitHub credential method is mounted. This is usually
      provided via the -path flag <span class="token keyword">in</span> the <span class="token string">&quot;vault login&quot;</span> command, but it can be
      specified here as well. If specified here, it takes precedence over the
      value <span class="token keyword">for</span> -path. The default value is <span class="token string">&quot;github&quot;</span><span class="token keyword">.</span>

  token<span class="token operator">=</span><span class="token operator">&lt;</span>string<span class="token operator">&gt;</span>
      GitHub personal access token to use <span class="token keyword">for</span> authentication. If not provided,
      Vault will prompt <span class="token keyword">for</span> the value.
</code></pre></div><p>可以获得 CLI <code>auth</code>方法的帮助信息：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ vault auth <span class="token function">help</span> aws

$ vault auth <span class="token function">help</span> userpass

$ vault auth <span class="token function">help</span> token
</code></pre></div><p>根据帮助输出，使用 <code>vault login</code> 命令对 GitHub 进行身份验证。输入你的
<a href="https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/" target="_blank" rel="noopener noreferrer">GitHub personal access token<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，
Vault 将验证你的身份。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ vault login -method<span class="token operator">=</span>github

GitHub Personal Access Token <span class="token punctuation">(</span>will be hidden<span class="token punctuation">)</span>:
Success<span class="token operator">!</span> You are now authenticated. The token information displayed below
is already stored <span class="token keyword">in</span> the token helper. You <span class="token keyword">do</span> NOT need to run <span class="token string">&quot;vault login&quot;</span>
again. Future Vault requests will automatically use this token.

Key                    Value
---                    -----
token                  7efb3969-8743-880f-e234-afca6e12d790
token_accessor         f7bfb6a3-c41e-eb87-5317-88a0aad200ae
token_duration         768h
token_renewable        <span class="token boolean">true</span>
token_policies         <span class="token punctuation">[</span>default my-policy<span class="token punctuation">]</span>
token_meta_org         hashicorp
token_meta_username    my-user
</code></pre></div><p>如输出所示，Vault 已经在令牌助手中保存了生成的令牌，因此不需要再次运 <code>vault login</code>。但是，我们刚刚创建的这个新用户在 Vault 中没有很多权限。
继续使用 root token 重新进行身份验证:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ vault login <span class="token operator">&lt;</span>initial-root-token<span class="token operator">&gt;</span>
</code></pre></div><p>使用带有 <code>-mode</code> 参数的 <code>vault token revoke</code> 从 <code>auth</code> 方法中撤销任何登录：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ vault token revoke -mode path auth/github
</code></pre></div><p>或者，禁用 GitHub <code>auth</code> 方法：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ vault auth disable github

Success<span class="token operator">!</span> Disabled the auth method <span class="token punctuation">(</span>if it existed<span class="token punctuation">)</span> at: github/
</code></pre></div><p>这也会撤销该 <code>auth</code> 方法的任何登录。</p> <h2 id="policies"><a href="#policies" aria-hidden="true" class="header-anchor">#</a> Policies</h2> <p>Vault 的策略控制用户可以访问的内容。在上一节中，我们了解了身份验证( <code>authentication</code> )。这一部分是关于授权( <code>authorization</code> )的。</p> <p>对于身份验证，Vault 可以启用和使用多个选项或方法。Vault 对于授权和策略总是使用相同的格式。所有 <code>auth</code> 方法都将身份映射回 Vault 配置的核心策略。</p> <p>一些内置的策略不能撤销。例如，<code>root</code> 和 <code>default</code> 策略是必需的策略，不能删除。<strong><code>default</code> 策略提供一组公共权限，默认情况下包含在所有令牌上。
<code>root</code> 策略提供一个令牌超级管理员权限</strong>，类似于 linux 机器上的 <code>root</code> 用户。</p> <h3 id="策略格式"><a href="#策略格式" aria-hidden="true" class="header-anchor">#</a> 策略格式</h3> <p>策略是用 <a href="https://github.com/hashicorp/hcl" target="_blank" rel="noopener noreferrer">HCL<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 编写的，但与 JSON 兼容。下面是一个策略示例:</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token comment"># Normal servers have version 1 of KV mounted by default, so will need these</span>
<span class="token comment"># paths:</span>
path <span class="token string">&quot;secret/*&quot;</span> <span class="token punctuation">{</span>
  capabilities <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&quot;create&quot;</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
path <span class="token string">&quot;secret/foo&quot;</span> <span class="token punctuation">{</span>
  capabilities <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&quot;read&quot;</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>

<span class="token comment"># Dev servers have version 2 of KV mounted by default, so will need these</span>
<span class="token comment"># paths:</span>
path <span class="token string">&quot;secret/data/*&quot;</span> <span class="token punctuation">{</span>
  capabilities <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&quot;create&quot;</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
path <span class="token string">&quot;secret/data/foo&quot;</span> <span class="token punctuation">{</span>
  capabilities <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&quot;read&quot;</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><p>有了这个策略，用户可以将任何 secrets 写入 <code>secret/</code>，但 <code>secret/foo</code> 除外，因为只有读访问是允许的。策略默认拒绝，因此不允许对未指定路径的任何访问。</p> <p>Vault 包含一个命令，它将根据规范自动格式化策略。它还会报告语法错误：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ vault policy <span class="token function">fmt</span> my-policy.hcl
</code></pre></div><p>策略格式在 API 路径上使用前缀匹配系统来确定访问控制。使用最特定的策略，或者是精确匹配，或者是最长的前缀 glob 匹配。</p> <p>由于 Vault 中的所有内容都必须通过 API 访问，因此这对 Vault 的每个方面都有严格的控制，包括启用 secrets 引擎、启用 <code>auth</code> 方法、身份验证以及访问 secrets。</p> <h3 id="编写策略"><a href="#编写策略" aria-hidden="true" class="header-anchor">#</a> 编写策略</h3> <p>使用命令行编写策略，要指定要上传的策略文件的路径：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ vault policy <span class="token function">write</span> my-policy my-policy.hcl

Success<span class="token operator">!</span> Uploaded policy: my-policy
</code></pre></div><p>下面是一个可以在终端复制粘贴的策略例子：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ vault policy <span class="token function">write</span> my-policy -<span class="token operator">&lt;&lt;</span><span class="token string">EOF
# Normal servers have version 1 of KV mounted by default, so will need these
# paths:
path &quot;secret/*&quot; {
  capabilities = [&quot;create&quot;]
}
path &quot;secret/foo&quot; {
  capabilities = [&quot;read&quot;]
}

# Dev servers have version 2 of KV mounted by default, so will need these
# paths:
path &quot;secret/data/*&quot; {
  capabilities = [&quot;create&quot;]
}
path &quot;secret/data/foo&quot; {
  capabilities = [&quot;read&quot;]
}
EOF</span>
</code></pre></div><p>查看策略列表：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ vault policy list

default
my-policy
root
</code></pre></div><p>查看策略详情：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ vault policy <span class="token function">read</span> my-policy

<span class="token comment"># Normal servers have version 1 of KV mounted by default, so will need these</span>
<span class="token comment"># paths:</span>
path <span class="token string">&quot;secret/*&quot;</span> <span class="token punctuation">{</span>
  capabilities <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&quot;create&quot;</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="测试策略"><a href="#测试策略" aria-hidden="true" class="header-anchor">#</a> 测试策略</h3> <p>要使用该策略，请创建一个令牌并将其分配给该策略：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ vault token create -policy<span class="token operator">=</span>my-policy

Key                  Value
---                  -----
token                Cdjlq3aR5XhfoWPLEzmwD1qL
token_accessor       3u0AvC7P3vyuBjqZKpgERuvk
token_duration       768h
token_renewable      <span class="token boolean">true</span>
token_policies       <span class="token punctuation">[</span><span class="token string">&quot;default&quot;</span> <span class="token string">&quot;my-policy&quot;</span><span class="token punctuation">]</span>
identity_policies    <span class="token punctuation">[</span><span class="token punctuation">]</span>
policies             <span class="token punctuation">[</span><span class="token string">&quot;default&quot;</span> <span class="token string">&quot;my-policy&quot;</span><span class="token punctuation">]</span>

$ vault login Cdjlq3aR5XhfoWPLEzmwD1qL

Success<span class="token operator">!</span> You are now authenticated. The token information displayed below
is already stored <span class="token keyword">in</span> the token helper. You <span class="token keyword">do</span> NOT need to run <span class="token string">&quot;vault login&quot;</span>
again. Future Vault requests will automatically use this token.

Key                  Value
---                  -----
token                Cdjlq3aR5XhfoWPLEzmwD1qL
token_accessor       3u0AvC7P3vyuBjqZKpgERuvk
token_duration       767h59m5s
token_renewable      <span class="token boolean">true</span>
token_policies       <span class="token punctuation">[</span><span class="token string">&quot;default&quot;</span> <span class="token string">&quot;my-policy&quot;</span><span class="token punctuation">]</span>
identity_policies    <span class="token punctuation">[</span><span class="token punctuation">]</span>
policies             <span class="token punctuation">[</span><span class="token string">&quot;default&quot;</span> <span class="token string">&quot;my-policy&quot;</span><span class="token punctuation">]</span>
</code></pre></div><p>验证可以向 <code>secret/</code> 写入任何数据，但只能从 <code>secret/foo</code> 读取:</p> <h4 id="dev-servers"><a href="#dev-servers" aria-hidden="true" class="header-anchor">#</a> Dev servers</h4> <div class="language-bash extra-class"><pre class="language-bash"><code>$ vault kv put secret/bar robot<span class="token operator">=</span>beepboop

Key              Value
---              -----
created_time     2018-11-01T02:55:34.721929175Z
deletion_time    n/a
destroyed        <span class="token boolean">false</span>
version          1

$ vault kv put secret/foo robot<span class="token operator">=</span>beepboop

Error writing data to secret/data/foo: Error making API request.

URL: PUT http://127.0.0.1:8200/v1/secret/data/foo
Code: 403. Errors:

* permission denied
</code></pre></div><h4 id="non-dev-servers"><a href="#non-dev-servers" aria-hidden="true" class="header-anchor">#</a> Non-dev servers</h4> <div class="language-bash extra-class"><pre class="language-bash"><code>$ vault kv put secret/bar robot<span class="token operator">=</span>beepboop

Success<span class="token operator">!</span> Data written to: secret/bar

$ vault kv put secret/foo robot<span class="token operator">=</span>beepboop

Error writing data to secret/foo: Error making API request.

URL: PUT http://127.0.0.1:8200/v1/secret/foo
Code: 403. Errors:

* permission denied
</code></pre></div><h3 id="映射策略到-auth-方法"><a href="#映射策略到-auth-方法" aria-hidden="true" class="header-anchor">#</a> 映射策略到 <code>auth</code> 方法</h3> <p>Vault 本身是单个策略权限，与身份验证不同，你可以在身份验证中启用多个 <code>auth</code> 方法。任何启用的 <code>auth</code> 方法都必须将身份映射到这些核心策略。</p> <p>在 <code>auth</code> 方法中使用 <code>vault path-help</code> 系统来确定映射是如何完成的，因为它是特定于每个 <code>auth</code> 方法的。例如，使用 GitHub，每个团队使用 <code>map/teams/&lt;team&gt;</code> 路径完成：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ vault <span class="token function">write</span> auth/github/map/teams/default value<span class="token operator">=</span>my-policy

Success<span class="token operator">!</span> Data written to: auth/github/map/teams/default
</code></pre></div><p>对于 GitHub 来说，默认团队是默认的策略集，每个人都被分配到它所在的任何一个团队。</p> <h2 id="部署-vault"><a href="#部署-vault" aria-hidden="true" class="header-anchor">#</a> 部署 Vault</h2> <p>部署生产环境下的 Vault。</p> <h3 id="配置-vault"><a href="#配置-vault" aria-hidden="true" class="header-anchor">#</a> 配置 Vault</h3> <p>Vault 使用 <a href="https://github.com/hashicorp/hcl" target="_blank" rel="noopener noreferrer">HCL<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 文件配置。Vault 的配置文件相对简单:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>storage <span class="token string">&quot;consul&quot;</span> <span class="token punctuation">{</span>
  address <span class="token operator">=</span> <span class="token string">&quot;127.0.0.1:8500&quot;</span>
  path    <span class="token operator">=</span> <span class="token string">&quot;vault/&quot;</span>
<span class="token punctuation">}</span>

listener <span class="token string">&quot;tcp&quot;</span> <span class="token punctuation">{</span>
 address     <span class="token operator">=</span> <span class="token string">&quot;127.0.0.1:8200&quot;</span>
 tls_disable <span class="token operator">=</span> 1
<span class="token punctuation">}</span>
</code></pre></div><p>这里有两个主要的配置：</p> <ul><li><code>storage</code> - 这是 Vault 用来存储的物理后端。开发服务器使用了 <code>inmem</code> (在内存中)，上面的例子使用了 <a href="https://www.consul.io/" target="_blank" rel="noopener noreferrer">Consul<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，一个更易于生产的后端。</li> <li><code>listener</code> - 一个或多个侦听器决定 Vault 如何侦听 API 请求。上面的示例在没有 <code>TLS</code> 的情况下监听 <code>localhost</code> 端口 <code>8200</code>。设置环境变量 <code>VAULT_ADDR=http://127.0.0.1:8200</code>，
以便 VAULT 客户端在没有 TLS 的情况下连接。</li></ul> <p>现在，将上面的配置复制粘贴到一个名为 <code>config.hcl</code> 的文件中。它将配置 Vault，并期望一个 Consul 实例在本地运行。</p> <p>如何启动 Consul 实例，参考 <a href="https://www.consul.io/intro/getting-started/install.html" target="_blank" rel="noopener noreferrer">Consul Getting Started Guide<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，安装好以后使用下面的命令启动：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ consul agent -dev
</code></pre></div><h3 id="启动-server-2"><a href="#启动-server-2" aria-hidden="true" class="header-anchor">#</a> 启动 server</h3> <p>配置好以后，启动服务器配合 <code>-config</code> 标志，指向配置的正确路径：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ vault server -config<span class="token operator">=</span>config.hcl

<span class="token operator">==</span><span class="token operator">&gt;</span> Vault server configuration:

         Log Level: info
           Storage: consul
        Listener 1: tcp <span class="token punctuation">(</span>addr: <span class="token string">&quot;127.0.0.1:8200&quot;</span>, tls: <span class="token string">&quot;disabled&quot;</span><span class="token punctuation">)</span>

<span class="token operator">==</span><span class="token operator">&gt;</span> Vault server started<span class="token operator">!</span> Log data will stream <span class="token keyword">in</span> below:
</code></pre></div><p>Vault 输出一些关于其配置的信息，然后阻塞。这个过程应该使用资源管理器(如 <code>systemd</code> 或 <code>upstart</code>)运行。</p> <p>你会注意到不能执行任何命令。我们没有任何授权信息!当第一次设置 Vault 服务器时，必须首先初始化它。</p> <p>在 Linux 上，Vault 可能无法启动并报错:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ vault server -config<span class="token operator">=</span>example.hcl

Error initializing core: Failed to lock memory: cannot allocate memory

This usually means that the mlock syscall is not available.
Vault uses mlock to prevent memory from being swapped to
disk. This requires root privileges as well as a machine
that supports mlock. Please <span class="token function">enable</span> mlock on your system or
disable Vault from using it. To disable Vault from using it,
<span class="token keyword">set</span> the <span class="token variable"><span class="token variable">`</span>disable_mlock<span class="token variable">`</span></span> configuration option <span class="token keyword">in</span> your configuration
file.
</code></pre></div><p>这个问题参考 <a href="https://www.vaultproject.io/docs/configuration/index.html" target="_blank" rel="noopener noreferrer">Server Configuration<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 中有关 <code>disable_mlock</code> 的讨论。</p> <h3 id="初始化-vault"><a href="#初始化-vault" aria-hidden="true" class="header-anchor">#</a> 初始化 Vault</h3> <p>初始化是配置 Vault 的过程。只有当服务器针对以前从未在 Vault 中使用过的新后端启动时，才会出现这种情况。在 HA 模式下运行时，每个集群一次，
而不是每个服务器一次。</p> <p>在初始化过程中，生成加密密钥，创建解锁密钥，并设置初始 <code>root token</code>。要初始化 Vault，使用 <code>vault operator init</code> 初始化 Vault。
这是一个没有验证的请求，但它只适用于没有数据的新的 Vault:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ vault operator init

Unseal Key 1: E4GnjX+VP9G50uWQNcwpCflzGAMKGR38BbQywgq4I6L8
Unseal Key 2: PYMxcCOswEYMNz7N6UW53Up6nu6y+SjAPwTJOTtkju3d
Unseal Key 3: yuJ5cSxC7tSBR5mMVJ/WJ9bfhhfGb+uwWw9FQR0JKILh
Unseal Key 4: 0vdvEFHM9PHEGMctJrl2ylHqoKQK8DLkfMU6ntmDz6jv
Unseal Key 5: cI8yglWJX+jPf/yQG7Sg6SPWzy0WyrBPvaFTOAYkPJTx

Initial Root Token: 62421926-81b9-b202-86f8-8850176c0cf3

Vault initialized with 5 key shares and a key threshold of 3. Please securely
distribute the key shares printed above. When the Vault is re-sealed,
restarted, or stopped, you must supply at least 3 of these keys to unseal it
before it can start servicing requests.

Vault does not store the generated master key. Without at least 3 key to
reconstruct the master key, Vault will remain permanently sealed<span class="token operator">!</span>

It is possible to generate new unseal keys, provided you have a quorum of
existing unseal keys shares. See <span class="token string">&quot;vault operator rekey&quot;</span> <span class="token keyword">for</span> <span class="token function">more</span> information.
</code></pre></div><p>初始化输出两个非常重要的信息: <code>unseal keys</code> 和 <code>root token</code>。
保存所有的 <code>unseal keys</code> 和 <code>root token</code>，在实际的部署场景中，永远不会将这些键保存在一起。相反，你可能会使用 Vault 的 <code>PGP</code> 和 <code>Keybase.io</code> 支持
加密这些密钥与用户的 <code>PGP</code> 密钥。这可以防止一个人拥有所有的解锁密钥。有关使用 PGP、GPG 和 Keybase 的详细信息，
请参阅<a href="https://www.vaultproject.io/docs/concepts/pgp-gpg-keybase.html" target="_blank" rel="noopener noreferrer">有关文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <h2 id="seal-unseal"><a href="#seal-unseal" aria-hidden="true" class="header-anchor">#</a> Seal/Unseal</h2> <p>每个初始化的 Vault 服务器都是在密封的状态下启动。从配置中，Vault 可以访问物理存储，但是它不能读取任何数据，因为它不知道如何解密它。教 Vault 如何解密数据的过程是已知的。</p> <p>每次 Vault 启动的时候都会解封。它可以通过 API 和命令行完成。要解封 Vault，你必须有阈值数的 <code>unseal keys</code>。上面的输出中，注意到 <code>key threshold</code> 是 3。
这意味着要解封 Vault，需要已经生成的 5 个 <code>unseal key</code> 中的 3 个。</p> <p>开始解封 Vault：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ vault operator unseal

Unseal Key <span class="token punctuation">(</span>will be hidden<span class="token punctuation">)</span>:
Key                Value
---                -----
Sealed             <span class="token boolean">true</span>
Total Shares       5
Unseal Progress    1/3
Unseal Nonce       786e7190-d1e2-84d2-520c-022efee5b71e
Version            <span class="token punctuation">(</span>version unknown<span class="token punctuation">)</span>
HA Enabled         <span class="token boolean">true</span>
HA Mode            sealed
</code></pre></div><p>在粘贴一个有效的密钥并确认之后，看到 Vault 仍然是密封的，但是已经取得了进展。Vault 知道它已经有了 3 个钥匙中的 1 个。由于算法的性质，
Vault 在达到阈值之前不知道它是否有正确的 <code>key</code>。</p> <p>还要注意，解封过程是有状态的。你可以到另一台计算机，使用 <code>vault operator unseal</code>，只要它指向同一个服务器，其他计算机就可以继续解锁过程。
这对于开启过程的设计是非常重要的: 解封 Vault 需要多个人带着多把钥匙。Vault 可以从多台电脑上打开，钥匙永远不应该放在一起。一个恶意操作没有足够的 <code>key</code> 来进行。</p> <p>继续使用 <code>vault operator unseal</code>解封 Vault。要解封 Vault，你必须使用三个不同的 <code>key</code>，相同的 <code>key</code> 重复将不起作用。当使用 <code>key</code> 时，只要它们是正确的，
很快就会看到这样的输出：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ vault operator unseal

Unseal Key <span class="token punctuation">(</span>will be hidden<span class="token punctuation">)</span>:
<span class="token comment"># ...</span>

$ vault operator unseal

Unseal Key <span class="token punctuation">(</span>will be hidden<span class="token punctuation">)</span>:
<span class="token comment"># ...</span>
</code></pre></div><p>当 <code>Sealed</code> 的值变成了 <code>false</code>，Vault 就被解封了：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>Key             Value
---             -----
Sealed          <span class="token boolean">false</span> <span class="token operator">&lt;</span>--
Total Shares    5
Version         <span class="token punctuation">(</span>version unknown<span class="token punctuation">)</span>
Cluster Name    vault-cluster-8a8b2c36
Cluster ID      34e94a2e-2d8f-c7cc-271d-96fd438ccc6d
HA Enabled      <span class="token boolean">true</span>
HA Mode         standby
HA Cluster      n/a
</code></pre></div><p>最后，验证 <code>root token</code>(和 <code>unseal key</code> 都在输出中):</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ vault login 14d1316e-78f6-910b-a4cc-9ba6697ec814

Success<span class="token operator">!</span> You are now authenticated. The token information displayed below
is already stored <span class="token keyword">in</span> the token helper. You <span class="token keyword">do</span> NOT need to run <span class="token string">&quot;vault login&quot;</span>
again. Future Vault requests will automatically use this token.

Key                Value
---                -----
token              14d1316e-78f6-910b-a4cc-9ba6697ec814
token_accessor     a8bbcc57-9be6-6584-a7a6-46290962fd33
token_duration     â
token_renewable    <span class="token boolean">false</span>
token_policies     <span class="token punctuation">[</span>root<span class="token punctuation">]</span>
</code></pre></div><p><code>root</code> 用户可以使用 <code>vault operator seal</code> 重新密封 Vault。如果重新密封 Vault，那么它会从内存中清除所有状态(包括加密密钥)。Vault 是安全的，并锁住访问。</p> <h2 id="使用带有身份验证的-http-apis"><a href="#使用带有身份验证的-http-apis" aria-hidden="true" class="header-anchor">#</a> 使用带有身份验证的 HTTP APIs</h2> <p>除了 CLI 之外，Vault 的所有功能都可以通过 HTTP API 访问。实际上，CLI的大多数调用实际上都调用HTTP API。在某些情况下，Vault 功能不能通过 CLI 访问，只能通过 HTTP API 访问。</p> <p>启动 Vault 服务器后，可以使用 <code>curl</code> 或任何其他 <code>http</code> 客户端进行 API 调用。例如，如果在 <a href="https://www.vaultproject.io/docs/concepts/dev-server.html" target="_blank" rel="noopener noreferrer">dev mode<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 下
启动 Vault 服务器，可以这样验证初始化状态：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">curl</span> http://127.0.0.1:8200/v1/sys/init

<span class="token punctuation">{</span><span class="token string">&quot;initialized&quot;</span>:true<span class="token punctuation">}</span>
</code></pre></div><h3 id="通过-rest-apis-访问-secrets"><a href="#通过-rest-apis-访问-secrets" aria-hidden="true" class="header-anchor">#</a> 通过 REST APIs 访问 secrets</h3> <p>通过它的 REST API 访问在 Vault 中的信息。例如，如果机器使用 <a href="https://www.vaultproject.io/docs/auth/approle.html" target="_blank" rel="noopener noreferrer">AppRole<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 进行身份验证，Vault 首先对应用程序将
进行身份验证，返回一个 <code>Vault API</code> 令牌。应用程序将使用该令牌与 Vault 通信。</p> <p>这里的例子没有启用 <code>TLS</code>，但是在生产环境下，<code>TLS</code> 不应该被禁用。保存下面的内容到 <code>config.hcl</code>，并且启动 Vault server：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token comment"># 基于文件</span>
backend <span class="token string">&quot;file&quot;</span> <span class="token punctuation">{</span>
  path <span class="token operator">=</span> <span class="token string">&quot;vault&quot;</span>
<span class="token punctuation">}</span>

listener <span class="token string">&quot;tcp&quot;</span> <span class="token punctuation">{</span>
  tls_disable <span class="token operator">=</span> 1
<span class="token punctuation">}</span>
</code></pre></div><p>启动：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ vault server -config<span class="token operator">=</span>config.hcl
</code></pre></div><p>至此，我们可以对所有交互使用 Vault API。例如，我们可以这样初始化 Vault:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">curl</span> \
    --request POST \
    --data <span class="token string">'{&quot;secret_shares&quot;: 1, &quot;secret_threshold&quot;: 1}'</span> \
    http://127.0.0.1:8200/v1/sys/init


<span class="token punctuation">{</span>
  <span class="token string">&quot;keys&quot;</span><span class="token keyword">:</span> <span class="token punctuation">[</span><span class="token string">&quot;373d500274dd8eb95271cb0f868e4ded27d9afa205d1741d60bb97cd7ce2fe41&quot;</span><span class="token punctuation">]</span>,
  <span class="token string">&quot;keys_base64&quot;</span><span class="token keyword">:</span> <span class="token punctuation">[</span><span class="token string">&quot;Nz1QAnTdjrlSccsPho5N7SfZr6IF0XQdYLuXzXzi/kE=&quot;</span><span class="token punctuation">]</span>,
  <span class="token string">&quot;root_token&quot;</span><span class="token keyword">:</span> <span class="token string">&quot;6fa4128e-8bd2-fd02-0ea8-a5e020d9b766&quot;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这个响应包含我们的 <code>root token</code> 和 <code>unseal key</code>。可以使用 <code>unseal key</code> 来解封 Vault，并使用 <code>root token</code> 在 Vault 中执行其他需要身份验证的请求。</p> <p>为了方便我们把 <code>root token</code> 保存到环境变量 <code>export VAULT_TOKEN=6fa4128e-8bd2-fd02-0ea8-a5e020d9b766</code>。</p> <p>使用 <code>unseal key</code> 通过 API 来解封 Vault：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">curl</span> \
    --request POST \
    --data <span class="token string">'{&quot;key&quot;: &quot;Nz1QAnTdjrlSccsPho5N7SfZr6IF0XQdYLuXzXzi/kE=&quot;}'</span> \
    http://127.0.0.1:8200/v1/sys/unseal

<span class="token punctuation">{</span>
  <span class="token string">&quot;sealed&quot;</span><span class="token keyword">:</span> false,
  <span class="token string">&quot;t&quot;</span><span class="token keyword">:</span> 1,
  <span class="token string">&quot;n&quot;</span><span class="token keyword">:</span> 1,
  <span class="token string">&quot;progress&quot;</span><span class="token keyword">:</span> 0,
  <span class="token string">&quot;nonce&quot;</span><span class="token keyword">:</span> <span class="token string">&quot;&quot;</span>,
  <span class="token string">&quot;version&quot;</span><span class="token keyword">:</span> <span class="token string">&quot;1.2.3&quot;</span>,
  <span class="token string">&quot;cluster_name&quot;</span><span class="token keyword">:</span> <span class="token string">&quot;vault-cluster-9d524900&quot;</span>,
  <span class="token string">&quot;cluster_id&quot;</span><span class="token keyword">:</span> <span class="token string">&quot;d69ab1b0-7e9a-2523-0d05-b0bfd09caeea&quot;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>现在所有可用的 <code>auth</code> 方法可以启用和配置了。这里使用 <a href="https://www.vaultproject.io/docs/auth/approle.html" target="_blank" rel="noopener noreferrer">AppRole<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 验证。
开始启用 AppRole 验证</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">curl</span> \
    --header <span class="token string">&quot;X-Vault-Token: <span class="token variable">$VAULT_TOKEN</span>&quot;</span> \
    --request POST \
    --data <span class="token string">'{&quot;type&quot;: &quot;approle&quot;}'</span> \
    http://127.0.0.1:8200/v1/sys/auth/approle
</code></pre></div><p>注意，启用 AppRole 端点的请求需要一个身份验证令牌。在本例中，我们将传递启动 Vault 服务器时生成的 <code>root token</code>。我们还可以
使用任何其他身份验证机制生成令牌，但为了简单起见，我们将使用 <code>root token</code>。</p> <p>现在，使用所需的 <a href="https://www.vaultproject.io/docs/concepts/policies.html" target="_blank" rel="noopener noreferrer">ACL 策略集<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>创建一个 AppRole。在下面的命令中，
指定在 AppRole <code>my-role</code> 下发布的令牌应该与 <code>dev-policy</code> 和 <code>my-policy</code>相 关联：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">curl</span> \
    --header <span class="token string">&quot;X-Vault-Token: <span class="token variable">$VAULT_TOKEN</span>&quot;</span> \
    --request POST \
    --data <span class="token string">'{&quot;policies&quot;: [&quot;dev-policy&quot;, &quot;my-policy&quot;]}'</span> \
    http://127.0.0.1:8200/v1/auth/approle/role/my-role
</code></pre></div><p>在默认配置中，AppRole 后端需要两个很难猜到的凭证，一个 <code>role ID</code> 和一个 <code>secret ID</code>。获取 <code>my-role</code> 的 <code>role ID</code>：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">curl</span> \
    --header <span class="token string">&quot;X-Vault-Token: <span class="token variable">$VAULT_TOKEN</span>&quot;</span> \
     http://127.0.0.1:8200/v1/auth/approle/role/my-role/role-id

<span class="token punctuation">{</span>
  <span class="token string">&quot;data&quot;</span><span class="token keyword">:</span> <span class="token punctuation">{</span>
    <span class="token string">&quot;role_id&quot;</span><span class="token keyword">:</span> <span class="token string">&quot;86a32a73-1f2b-05e0-113a-dfa930145d72&quot;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>创建 <code>my-role</code> 的 <code>secret ID</code>：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">curl</span> \
    --header <span class="token string">&quot;X-Vault-Token: <span class="token variable">$VAULT_TOKEN</span>&quot;</span> \
    --request POST \
    http://127.0.0.1:8200/v1/auth/approle/role/my-role/secret-id

<span class="token punctuation">{</span>
  <span class="token string">&quot;data&quot;</span><span class="token keyword">:</span> <span class="token punctuation">{</span>
    <span class="token string">&quot;secret_id&quot;</span><span class="token keyword">:</span> <span class="token string">&quot;cd4b2002-3e3b-aceb-378d-5caa84dffd14&quot;</span>,
    <span class="token string">&quot;secret_id_accessor&quot;</span><span class="token keyword">:</span> <span class="token string">&quot;6b9b58f6-d11a-c73c-ffa8-04a47d42716b&quot;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这两个凭证可以提供给 <code>login</code> 端点以获取新的 Vault 令牌。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">curl</span> \
    --request POST \
    --data <span class="token string">'{&quot;role_id&quot;: &quot;86a32a73-1f2b-05e0-113a-dfa930145d72&quot;, &quot;secret_id&quot;: &quot;cd4b2002-3e3b-aceb-378d-5caa84dffd14&quot;}'</span> \
    http://127.0.0.1:8200/v1/auth/approle/login

<span class="token punctuation">{</span>
  <span class="token string">&quot;auth&quot;</span><span class="token keyword">:</span> <span class="token punctuation">{</span>
    <span class="token string">&quot;client_token&quot;</span><span class="token keyword">:</span> <span class="token string">&quot;50617721-dfb5-1916-7b13-4091e169d28c&quot;</span>,
    <span class="token string">&quot;accessor&quot;</span><span class="token keyword">:</span> <span class="token string">&quot;ada8d354-47c0-5d9e-50f9-d74e6de2df9b&quot;</span>,
    <span class="token string">&quot;policies&quot;</span><span class="token keyword">:</span> <span class="token punctuation">[</span><span class="token string">&quot;default&quot;</span>, <span class="token string">&quot;dev-policy&quot;</span>, <span class="token string">&quot;my-policy&quot;</span><span class="token punctuation">]</span>,
    <span class="token string">&quot;metadata&quot;</span><span class="token keyword">:</span> <span class="token punctuation">{</span>
      <span class="token string">&quot;role_name&quot;</span><span class="token keyword">:</span> <span class="token string">&quot;my-role&quot;</span>
    <span class="token punctuation">}</span>,
    <span class="token string">&quot;lease_duration&quot;</span><span class="token keyword">:</span> 2764800,
    <span class="token string">&quot;renewable&quot;</span><span class="token keyword">:</span> <span class="token boolean">true</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这个 <code>client_token</code> 可以用作 Vault 的身份验证。这个令牌将被授权使用 <code>default</code>,<code>dev-policy</code> 和 <code>my-policy</code> 策略所包含的所有资源的特定功能。</p> <p>新获得的令牌可以作为新的 VAULT 令牌导出，并使用它对 VAULT 请求进行身份验证。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">export</span> VAULT_TOKEN<span class="token operator">=</span><span class="token string">&quot;50617721-dfb5-1916-7b13-4091e169d28c&quot;</span>

<span class="token comment"># 写入新的secret foo</span>
$ <span class="token function">curl</span> \
    --header <span class="token string">&quot;X-Vault-Token: <span class="token variable">$VAULT_TOKEN</span>&quot;</span> \
    --request POST \
    --data <span class="token string">'{&quot;bar&quot;: &quot;baz&quot;}'</span> \
    http://127.0.0.1:8200/v1/secret/foo

<span class="token comment"># 读取 foo</span>
$ <span class="token function">curl</span> \
    --header <span class="token string">&quot;X-Vault-Token: <span class="token variable">$VAULT_TOKEN</span>&quot;</span> \
    http://127.0.0.1:8200/v1/secret/foo

<span class="token punctuation">{</span>
  <span class="token string">&quot;data&quot;</span><span class="token keyword">:</span> <span class="token punctuation">{</span>
    <span class="token string">&quot;bar&quot;</span><span class="token keyword">:</span> <span class="token string">&quot;baz&quot;</span>
  <span class="token punctuation">}</span>,
  <span class="token string">&quot;lease_duration&quot;</span><span class="token keyword">:</span> 2764800,
  <span class="token string">&quot;renewable&quot;</span><span class="token keyword">:</span> false,
  <span class="token string">&quot;request_id&quot;</span><span class="token keyword">:</span> <span class="token string">&quot;5e246671-ec05-6fc8-9f93-4fe4512f34ab&quot;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>更多 APIs 参考 <a href="https://www.vaultproject.io/api/index.html" target="_blank" rel="noopener noreferrer">HTTP APIs 文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <h2 id="web-ui"><a href="#web-ui" aria-hidden="true" class="header-anchor">#</a> Web UI</h2> <p>Vault 提供了一个用户交互界面。使用 Vault UI 可以轻松地创建、读取、更新和删除 secrets、进行身份验证、解封等等。</p> <h3 id="dev-servers-2"><a href="#dev-servers-2" aria-hidden="true" class="header-anchor">#</a> Dev servers</h3> <p>当你在 dev 模式下启动 Vault server 时，Vault UI 会自动启用。在浏览器输入 <code>http://127.0.0.1:8200/ui</code> 来访问。</p> <p>输入 root token 来登录。</p> <h3 id="non-dev-servers-2"><a href="#non-dev-servers-2" aria-hidden="true" class="header-anchor">#</a> Non-Dev servers</h3> <p>在非 dev 模式下，Vault UI 默认是不启用的。要启用 Vault UI，需要在 Vault 配置文件中设置 <code>ui</code> 选项。</p> <div class="language- extra-class"><pre class="language-text"><code>ui = true

listener &quot;tcp&quot; {
  # ...
}

storage &quot;consul&quot; {
  # ...
}
</code></pre></div><p>Vault UI 运行的端口和 Vault server 相同。因此，必须配置至少一个监听的端口才能访问 Vault UI。</p> <p>例如：</p> <div class="language- extra-class"><pre class="language-text"><code>ui = true

listener &quot;tcp&quot; {
  address = &quot;10.0.1.35:8200&quot;

  # If bound to localhost, the Vault UI is only
  # accessible from the local machine!
  # address = &quot;127.0.0.1:8200&quot;
}
...
</code></pre></div><p>在这个例子中，可以从子网上的任何机器(假设没有网络防火墙)访问以下 URL: <code>https://10.0.1.35:8200/ui</code>。</p> <h3 id="web-ui-wizard"><a href="#web-ui-wizard" aria-hidden="true" class="header-anchor">#</a> Web UI Wizard</h3> <p>Vault UI 有一个内置的指南，可以指导你完成各种常见 Vault 特性的操作。</p></div> <div class="page-edit"><div class="edit-link"><a href="https://github.com/shipengqi/vault-docs-Zh-CN/edit/master/docs/guide/README.md" target="_blank" rel="noopener noreferrer">错别字纠正</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <!----></div> <!----> </div> <!----></div></div>
    <script src="/vault-docs-Zh-CN/assets/js/16.686d05ff.js" defer></script><script src="/vault-docs-Zh-CN/assets/js/app.341f2fd2.js" defer></script>
  </body>
</html>
